// Copyright 2025 Timoth√© Lapetite and contributors
// Released under the MIT license https://opensource.org/license/MIT/

using System.Collections.Generic;
using System.IO;
using System.Text;
using UnrealBuildTool;

public class PCGExtendedToolkit : ModuleRules
{
	private List<string> EnabledSubModules = new List<string>();

	public PCGExtendedToolkit(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
		bUseUnity = true;
		
		LoadSubModulesFromConfig();
		
		EnabledSubModules.Insert(0, "PCGExFoundations"); // Load Foundations first
		GenerateSubModulesHeader();

		PublicIncludePaths.AddRange(
			new string[]
			{
			}
		);

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"CoreUObject",
				"Engine",
				"PCG",
				"PCGExCore",
				"PCGExBlending"
			}
		);


		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"DeveloperSettings"
			}
		);


		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
			}
		);

		if (Target.bBuildEditor == true)
		{
			PrivateDependencyModuleNames.AddRange(
				new string[]
				{
					"UnrealEd",
					"Settings",
					"PCGExCoreEditor",
					"PCGExFoundationsEditor"
				});
		}
	}

	private void LoadSubModulesFromConfig()
	{
		string SubModulesConfig = Path.GetFullPath(Path.Combine(ModuleDirectory, "..", "..", "SubModules.ini"));

		// Register as external dependency - changes trigger rebuild
		ExternalDependencies.Add(SubModulesConfig);

		if (!File.Exists(SubModulesConfig))
		{
			return;
		}

		foreach (string Line in File.ReadAllLines(SubModulesConfig))
		{
			string Trimmed = Line.Trim();

			// Skip empty lines and comments
			if (string.IsNullOrEmpty(Trimmed) || Trimmed.StartsWith("#") || Trimmed.StartsWith(";"))
			{
				continue;
			}

			// Parse "ModuleName=1" or "ModuleName=0"
			string[] Parts = Trimmed.Split('=');
			if (Parts.Length == 2)
			{
				string ModuleName = Parts[0].Trim();
				bool Enabled = Parts[1].Trim() == "1";
				ToggleOptionalModule(ModuleName, Enabled);
			}
		}
	}

	private void ToggleOptionalModule(string ModuleName, bool Enabled)
	{
		if (!Enabled)
		{
			return;
		}

		PublicDependencyModuleNames.Add(ModuleName);

		// Track enabled PCGEx modules (excluding umbrella modules)
		if (ModuleName.StartsWith("PCGEx") &&
		    ModuleName != "PCGExtendedToolkit" &&
		    ModuleName != "PCGExtendedToolkitEditor")
		{
			EnabledSubModules.Add(ModuleName);
		}

		if (Target.bBuildEditor == true)
		{
			// Check for companion editor module
			string EditorModuleName = ModuleName + "Editor";
			string EditorModulePath = Path.Combine(ModuleDirectory, "..", EditorModuleName);

			if (Directory.Exists(EditorModulePath))
			{
				PrivateDependencyModuleNames.Add(EditorModuleName);

				// Track editor modules too
				if (EditorModuleName.StartsWith("PCGEx") &&
				    EditorModuleName != "PCGExtendedToolkitEditor")
				{
					EnabledSubModules.Add(EditorModuleName);
				}
			}
		}
	}

	private void GenerateSubModulesHeader()
	{
		
		// Create a header file with the list of selected modules
		// This will be used by the main plugin module to load compiled & selected modules individually.
		
		string GeneratedDir = Path.Combine(ModuleDirectory, "Private", "Generated");
		string HeaderPath = Path.Combine(GeneratedDir, "PCGExSubModules.generated.h");

		StringBuilder sb = new StringBuilder();
		sb.AppendLine("// Auto-generated by PCGExtendedToolkit.Build.cs - DO NOT EDIT");
		sb.AppendLine("#pragma once");
		sb.AppendLine();
		sb.AppendLine("#include \"CoreMinimal.h\"");
		sb.AppendLine();
		sb.AppendLine("namespace PCGExSubModules");
		sb.AppendLine("{");
		sb.AppendLine("\tinline TArray<FString> GetEnabledModules()");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\treturn {");

		for (int i = 0; i < EnabledSubModules.Count; i++)
		{
			string comma = (i < EnabledSubModules.Count - 1) ? "," : "";
			sb.AppendLine($"\t\t\tTEXT(\"{EnabledSubModules[i]}\"){comma}");
		}

		sb.AppendLine("\t\t};");
		sb.AppendLine("\t}");
		sb.AppendLine("}");

		// Only write if content changed to avoid unnecessary rebuilds
		Directory.CreateDirectory(GeneratedDir);

		string newContent = sb.ToString();
		if (!File.Exists(HeaderPath) || File.ReadAllText(HeaderPath) != newContent)
		{
			File.WriteAllText(HeaderPath, newContent);
		}
	}
}