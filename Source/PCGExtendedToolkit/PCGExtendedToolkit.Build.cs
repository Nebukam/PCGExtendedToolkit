// Copyright 2025 Timoth√© Lapetite and contributors
// Released under the MIT license https://opensource.org/license/MIT/

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnrealBuildTool;
using EpicGames.Core;

public class PCGExtendedToolkit : ModuleRules
{
	private List<string> EnabledSubModules = new List<string>();

	public PCGExtendedToolkit(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
		bUseUnity = true;

		LoadSubModulesFromConfig();

		PublicIncludePaths.AddRange(
			new string[]
			{
			}
		);

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"CoreUObject",
				"Engine",
				"PCG",
				"PCGExCore",
				"PCGExBlending"
			}
		);


		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"DeveloperSettings"
			}
		);


		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
			}
		);

		if (Target.bBuildEditor == true)
		{
			PrivateDependencyModuleNames.AddRange(
				new string[]
				{
					"UnrealEd",
					"Settings",
					"PCGExCoreEditor",
					"PCGExFoundationsEditor"
				});
		}

		ScanSubModuleDependencies();
		GenerateSubModulesHeader();
		UpdateUpluginFile();
	}

	private void LoadSubModulesFromConfig()
	{
		string SubModulesConfig = Path.GetFullPath(Path.Combine(ModuleDirectory, "..", "..", "SubModules.ini"));

		// Register as external dependency - changes trigger rebuild
		ExternalDependencies.Add(SubModulesConfig);

		if (!File.Exists(SubModulesConfig))
		{
			return;
		}

		foreach (string Line in File.ReadAllLines(SubModulesConfig))
		{
			string Trimmed = Line.Trim();

			// Skip empty lines and comments
			if (string.IsNullOrEmpty(Trimmed) || Trimmed.StartsWith("#") || Trimmed.StartsWith(";"))
			{
				continue;
			}

			// Parse "ModuleName=1" or "ModuleName=0"
			string[] Parts = Trimmed.Split('=');
			if (Parts.Length == 2)
			{
				string ModuleName = Parts[0].Trim();
				bool Enabled = Parts[1].Trim() == "1";
				ToggleOptionalModule(ModuleName, Enabled);
			}
		}
	}

	private void ToggleOptionalModule(string ModuleName, bool Enabled)
	{
		if (!Enabled)
		{
			return;
		}

		PublicDependencyModuleNames.Add(ModuleName);

		// Track enabled PCGEx modules (excluding umbrella modules)
		if (ModuleName.StartsWith("PCGEx") &&
		    ModuleName != "PCGExtendedToolkit" &&
		    ModuleName != "PCGExtendedToolkitEditor")
		{
			EnabledSubModules.Add(ModuleName);
		}

		if (Target.bBuildEditor == true)
		{
			// Check for companion editor module
			string EditorModuleName = ModuleName + "Editor";
			string EditorModulePath = Path.Combine(ModuleDirectory, "..", EditorModuleName);

			if (Directory.Exists(EditorModulePath))
			{
				PrivateDependencyModuleNames.Add(EditorModuleName);

				// Track editor modules too
				if (EditorModuleName.StartsWith("PCGEx") &&
				    EditorModuleName != "PCGExtendedToolkitEditor")
				{
					EnabledSubModules.Add(EditorModuleName);
				}
			}
		}
	}

	private Dictionary<string, List<string>> ModuleDependencies = new Dictionary<string, List<string>>();

	private void ScanSubModuleDependencies()
	{
		foreach (string ModuleName in EnabledSubModules)
		{
			if (ModuleName.EndsWith("Editor") && !Target.bBuildEditor)
			{
				continue;
			}

			string BuildCsPath = Path.Combine(ModuleDirectory, "..", ModuleName, ModuleName + ".Build.cs");

			if (!File.Exists(BuildCsPath))
			{
				continue;
			}

			string Content = File.ReadAllText(BuildCsPath);
			List<string> Dependencies = new List<string>();

			// Match any "PCGEx..." strings in dependency arrays
			var Matches = System.Text.RegularExpressions.Regex.Matches(
				Content,
				@"""(PCGEx\w+)"""
			);

			foreach (System.Text.RegularExpressions.Match Match in Matches)
			{
				string Dep = Match.Groups[1].Value;

				// Don't add self-reference
				if (Dep != ModuleName && !Dependencies.Contains(Dep))
				{
					Dependencies.Add(Dep);
				}
			}

			ModuleDependencies[ModuleName] = Dependencies;
		}
	}

	private void GenerateSubModulesHeader()
	{
		string GeneratedDir = Path.Combine(ModuleDirectory, "Private", "Generated");
		string HeaderPath = Path.Combine(GeneratedDir, "PCGExSubModules.generated.h");

		StringBuilder sb = new StringBuilder();
		sb.AppendLine("// Auto-generated by PCGExtendedToolkit.Build.cs - DO NOT EDIT");
		sb.AppendLine("#pragma once");
		sb.AppendLine();
		sb.AppendLine("#include \"CoreMinimal.h\"");
		sb.AppendLine();
		sb.AppendLine("namespace PCGExSubModules");
		sb.AppendLine("{");

		// Module list
		sb.AppendLine("\tinline const TArray<FString>& GetEnabledModules()");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tstatic TArray<FString> Modules = {");
		for (int i = 0; i < EnabledSubModules.Count; i++)
		{
			string comma = (i < EnabledSubModules.Count - 1) ? "," : "";
			sb.AppendLine($"\t\t\tTEXT(\"{EnabledSubModules[i]}\"){comma}");
		}

		sb.AppendLine("\t\t};");
		sb.AppendLine("\t\treturn Modules;");
		sb.AppendLine("\t}");
		sb.AppendLine();

		// Dependency map
		sb.AppendLine("\tinline const TMap<FString, TArray<FString>>& GetModuleDependencies()");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tstatic TMap<FString, TArray<FString>> Dependencies = {");
		int count = 0;
		foreach (var kvp in ModuleDependencies)
		{
			string comma = (count < ModuleDependencies.Count - 1) ? "," : "";

			if (kvp.Value.Count == 0)
			{
				sb.AppendLine($"\t\t\t{{ TEXT(\"{kvp.Key}\"), {{}} }}{comma}");
			}
			else
			{
				string deps = string.Join(", ", kvp.Value.Select(d => $"TEXT(\"{d}\")"));
				sb.AppendLine($"\t\t\t{{ TEXT(\"{kvp.Key}\"), {{ {deps} }} }}{comma}");
			}

			count++;
		}

		sb.AppendLine("\t\t};");
		sb.AppendLine("\t\treturn Dependencies;");
		sb.AppendLine("\t}");

		sb.AppendLine("}");

		Directory.CreateDirectory(GeneratedDir);

		string newContent = sb.ToString();
		if (!File.Exists(HeaderPath) || File.ReadAllText(HeaderPath) != newContent)
		{
			File.WriteAllText(HeaderPath, newContent);
		}
	}


	private void UpdateUpluginFile()
	{
		string UpluginPath = Path.Combine(ModuleDirectory, "..", "..", "PCGExtendedToolkit.uplugin");

		if (!File.Exists(UpluginPath))
		{
			return;
		}

		string Content = File.ReadAllText(UpluginPath);

		// Find "Modules" array bounds
		int ModulesStart = Content.IndexOf("\"Modules\"");
		if (ModulesStart == -1)
		{
			return;
		}

		// Find the opening bracket
		int ArrayStart = Content.IndexOf('[', ModulesStart);
		if (ArrayStart == -1)
		{
			return;
		}

		// Find matching closing bracket
		int BracketCount = 1;
		int ArrayEnd = ArrayStart + 1;
		while (ArrayEnd < Content.Length && BracketCount > 0)
		{
			if (Content[ArrayEnd] == '[') BracketCount++;
			else if (Content[ArrayEnd] == ']') BracketCount--;
			ArrayEnd++;
		}

		// Build module entries
		List<string> ModuleEntries = new List<string>();

		ModuleEntries.Add(BuildModuleEntry("PCGExtendedToolkit", false));
		ModuleEntries.Add(BuildModuleEntry("PCGExtendedToolkitEditor", true));

		foreach (string ModuleName in EnabledSubModules)
		{
			bool IsEditor = ModuleName.EndsWith("Editor");
			ModuleEntries.Add(BuildModuleEntry(ModuleName, IsEditor));
		}

		string ModulesJson = "[\n" + string.Join(",\n", ModuleEntries) + "\n  ]";

		// Replace just the Modules array
		string NewContent = Content.Substring(0, ArrayStart) + ModulesJson + Content.Substring(ArrayEnd);

		if (Content != NewContent)
		{
			File.WriteAllText(UpluginPath, NewContent);
		}
	}

	private string BuildModuleEntry(string ModuleName, bool IsEditor)
	{
		if (IsEditor)
		{
			return $@"    {{
      ""Name"": ""{ModuleName}"",
      ""Type"": ""Editor"",
      ""LoadingPhase"": ""Default"",
      ""PlatformAllowList"": [
        ""Win64"",
        ""Mac"",
        ""Linux""
      ]
    }}";
		}
		else
		{
			return $@"    {{
      ""Name"": ""{ModuleName}"",
      ""Type"": ""Runtime"",
      ""LoadingPhase"": ""Default"",
      ""PlatformAllowList"": [
        ""Win64"",
        ""Mac"",
        ""IOS"",
        ""Android"",
        ""Linux"",
        ""LinuxArm64""
      ]
    }}";
		}
	}
}